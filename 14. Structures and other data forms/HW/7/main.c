// main.c -- файл с главной функцией программы.
// Информация о библиотеке хранится в файле book.dat;
// программа реализует функционал добавления книг в библиотеку, редактирования записей о книгах,
// а также удаления книг из библитеки.
// Поскольку требования к реализации предписывают
// править файл (а не перезаписывать его) и  уделять основное внимание перемещению указателя позиции в нем,
// принято решение перезаписывать удаляемые записи
// в текущем файле book.dat структурами, содержащими нулевые строки в полях title, author и 0.0 в поле value 
// сначала все записи из файла копируются в буфер, представленный массивом структур BOOK,
// все изменения записей пользователем отражаются на этих данных,
// после чего происходит редактирование содержимого файла
#include"library.h"

int main (void)
{
	BOOK library[MAXBKS];				// массив структур BOOK с информацией по книгам из библиотеки
	int index, filecount;				// переменные для перемещения по массиву и для хранения текущего количества не пустых записей в файле book.dat
	int choice = 0;					// переменная для организации меню, хранящая ввод пользователя с выбором пункта меню
	FILE * pbooks;					// указатель на поток book.dat
	
	if ((pbooks = fopen("book.dat", "r+b")) == NULL)		// попытка открытия потока
	{
		fputs("Не удается открыть файл book.dat\n", stderr);	// вывод сообщения об ошибке в случае неудачи
		exit(EXIT_FAILURE);					// завершение программы
	}

	for (index = 0; index < MAXBKS; index++)
		library[index].status = 1;				// пробегаемся по массиву данных и помечаем каждую структуру как удаленную

	ld(pbooks, library, MAXBKS);
	if ((filecount = readf(pbooks)) == 0)
		puts("Сейчас ваша библиотека пуста. В ваших силах это изменить!");

	printf("\nПрограмма-меню. Изменяет информацию в вашей библиотеке.\n"
			"Выберите действие:\n");
	while (choice != 5)
	{
		printf("\n1 - изменить существующую запись; 2 - добавить новую запись;\n"
				"3 - удалить существующую запись; 4 - отобразить текущее содержимое файла book.dat.\n"
				"5 - завершить коррекцию списка.\n");
		while (scanf("%d", &choice) != 1 || choice < 1 || choice > 5)
		{
			fprintf(stderr, "Ошибка ввода!\n"
					"Введите целое число из диапазона 1 - 5.\n");
			eatline();
		}
		eatline();

		switch (choice)
		{
			case 1:
				if (filecount > 0)		// если количество записей в файле больше 0, есть, что изменять
				{
					printf("Введите номер записи, "
							"информацию в которой вы хотите изменить.\n");
					while (scanf("%d", &index) != 1 || index < 1 || index > filecount || 
						library[index - 1].status == 1)		// пока от пользователя не будет получен валидный ввод,
											// выводится сообщение об ошибке
					{
						fprintf(stderr, "Ошибка ввода!\n"
								"Книга отсутствует в списке."
								" Возможно, она была удалена ранее.\n"
								"Повторите ввод:\n");
					eatline();					// чистим буфер от лишних символов
					}
					eatline();

					edit_rec(index, library);
				}
				else
					fprintf(stderr, "Изменять нечего. Записей нет.\n");		// если изменять нечего, выводим сообщение об ошибке
			break;
			case 2:
				for (index = 0; index < MAXBKS; index++)				// ищем первую структуру, помеченную удаленной
					if (library[index].status == 1)					// на её место будет добавлена новая
						break;
				if (index == MAXBKS)							// если место для добавления так и не найдено
					fprintf(stderr, "Список полон!\n");				// выводим сообщение об ошибке
				else									// в противном случае, производим добавление новой структуры
													// в найденное место
					add_rec(index, library);
			break;
			case 3:
				if (filecount > 0)							// если файл содержит записи, есть, что удалять
				{
					for (index = 0; index < MAXBKS; index++)
						if (library[index].status != 1)
							break;
					if (index == MAXBKS)
						fprintf(stderr, "Удалять нечего. Записей нет.\n");
					else
					{
						printf("Введите номер записи, которую вы хотите удалить.\n");
						while (scanf("%d", &index) != 1 || index < 1 || index > filecount ||
								library[index - 1].status == 1)			// добиваемся валидного номера от пользователя
						{
							fprintf(stderr, "Ошибка ввода!\n"
									"Книга отсутствует в списке.\n"
									"Возможно, она была удалена ранее.\n"
									"Повторите ввод:\n");
							eatline();
						}
						eatline();
					
						del_rec(index, library);
					}
				}
				else									// если удалять нечего, выводим соответствующее сообщение
					fprintf(stderr, "Удалять нечего. Записей нет.\n");
			break;
			case 4:
				unld(pbooks, library, MAXBKS);
				if ((filecount = readf(pbooks)) == 0)
					puts("Файл book.dat сейчас пуст.");
			break;
		}
	}

	unld(pbooks, library, MAXBKS);
	if ((filecount = readf(pbooks)) == 0)
		puts("Совсем нет книг? Плохо.");
	
	if (fclose(pbooks))	// закрываем поток. При ошибке, выводим сообщение
		fprintf(stderr, "Ошибка при закрытии файла book.dat.\n");
	
	puts("Программа завершена.");

	return 0;
}
