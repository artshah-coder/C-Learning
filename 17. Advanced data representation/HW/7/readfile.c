/* readfile.c -- читает файл и строит бинарное дерево поиска из слов из этого файла */
#include"tree.h"
#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>
#include<string.h>

/* прототипы локальных функций */

// функция строит бинарное дерево поиска из слов, прочитанных из файла
// предусловия:	fp - указатель на файловый поток, ptr - указатель на бинарное дерево
// постусловия:	из слов, прочитанных из файла fp строится бинарное дерево поиска
static void BuildTree (FILE * fp, Tree * ptr);

// функция отображает пользовательское меню меню, считывает ввод пользователя
// и возвращает его
static char menu (void);

// вспомогательная функция для очистки буфера ввода от лишних символов
static void eatline (void);

// функция печати содержимого узла дерева
// предусловия:	item - элемент узла
// постусловия:	элемент выводится на экран
static void PrintItem (Item item);

int main (void)
{
	FILE * fp;		// файловый поток
	Tree words;		// бинарное дерево
	char ch;		// переменная, хранящая выбор пользователя
	char * input;		// указатель на строку, хранящий ввод пользователя
				// при поиске слова в дерева
				// память под хранение строки будет выделяться
				// динамически
	int i = 0;		// вспомогательная переменная для организации цикла
				// при динамическом выделении памяти
	
	if ((fp = fopen("file", "r")) == NULL)	// открываем файл
	{
		fprintf(stderr, "Ошибка при открытии файла file.\n");
		exit(EXIT_FAILURE);	// если указатель на файловый поток NULL,
					// завершаем работу программы 
	}

	InitializeTree(&words);	// Инициализируем дерево пустым содержимым
	BuildTree(fp, &words);	// Строим дерево из слов файла
	puts("Программа строит бинарное дерево поиска из слов файла file.");
	puts("А также способна с помощью меню отображать статистику встречаемости слов в файле file.");
	while ((ch = menu()) != 'q')
	{
		switch (ch)
		{
			case 'l':
				printf("%25s %s\n", "СЛОВО", "ЧАСТОТА");
				Traverse (&words, PrintItem);
				break;
			case 'i':
				input = (char *) malloc (sizeof(char));	// запрашиваем память пока на один символ
				if (NULL == input)	// проверяем, выделилась ли память
				{
					fprintf(stderr, "Ошибка при выделении памяти.\n");
					exit(EXIT_FAILURE);	// в случае ошибки при выделении памяти,
								// выводим сообщение и завершаем программу
				}
				
				printf("Введите искомое слово, длиной не более %d символов:\n", SLEN);
				while ((ch = getchar()) != EOF && !isspace(ch))	// читаем stdin, пока не встретим конец
										// файла или пробельный символ
				{
					input = (char *) realloc (input, sizeof(char)*(++i + 1));	// запрашиваем память
					// для следующего по порядку символа + 1 - для нулевого символа конца строки
					if (NULL == input)	// проверяем, выделилась ли память
					{
						fprintf(stderr, "Ошибка при выделении памяти.\n");
						exit(EXIT_FAILURE);	// в случае ошибки при выделении памяти,
									// выводим сообщение и завершаем работу
					}
					*(input + i - 1) = tolower(ch);	// переводим введенный символ в нижний регистр,
									// сохраняем по нужному адресу
				}
				if (i > 0)	// если ввод был произведен
					*(input + i) = '\0'; // формируем С-строку путем добавления 0-символа в конец
				printf("Слово %s содержится в файле file ", input);
				if (InTree(input, &words))	// проверяем, содержится ли введенное слово в дереве
					printf("%d раз.\n", InTree(input, &words));
				else
					printf("0 раз.\n");
				break;
			case 'q':
				break;
			default:
				puts("Ошибка в switch().");
				break;
		}
	}
	if (fclose(fp))	// Закрываем файловый поток, проверяем на ошибки
		fprintf(stderr, "Ошибка при закрытии файла file.\n");

	puts("Программа завершена.");

	return 0;
}

static void BuildTree (FILE * fp, Tree * ptr)
{
	char ch;		// переменная для посимвольноого чтения файла
	char * word;		// указатель на строку для хранения считанных слов
				// память выделяем динамически

	word = (char *) malloc (sizeof(char));	// запрашиваем у ОС память для первого символа

	if (NULL == word)	// проверяем, выделилась ли память
	{
		fprintf(stderr, "Ошибка при выделении памяти.\n");
		exit(EXIT_FAILURE);	// в случае ошибки, выводим сообщение и завершаем программу
	}

	while ((ch = fgetc(fp)) != EOF)	// посимвольно читаем файл
	{
		int i = 0;	// объявляем локальную переменную для организации цикла при выделении памяти
		for (; !isspace(ch) && ch != EOF; ch = fgetc(fp))	// пока символ не пробел и не равен EOF,
									// читаем символы из файла
		{
			word = (char *) realloc (word, sizeof(char)*(++i + 1));	// запрашиваем память под новый символ
			if (word == NULL)					// проверяем, выделилась ли память
			{
				fprintf(stderr, "Ошибка при выделении памяти.\n");
				exit(EXIT_FAILURE);	// в случае ошибки, выводим сообщение и завершаем программу
			}
			*(word + i - 1) = tolower(ch);	// переводим симол в нижний регистр,
							// сохраняем по нужному адресу
		}
		if (i > 0)	// если слово было считано
			*(word + i) = '\0'; // завершаем С-строку стандартным 0-символом
		AddItem (word, ptr);	// добавляем слово в дерево
	}
}

static void PrintItem (Item item)
{
	printf("%20s %3d\n", item.word, item.count);
}

static char menu (void)
{
	char choice;
	printf("\nВведите букву, соответствующую вашему выбору:\n"
			"l - отображение статистики по всем словам в файле file;	i - ввести слово, статистику по которому вы хотите узнать;\n"
			"q - выход из программы.\n");
	while ((choice = getchar()) != EOF)
	{
		eatline();
		choice = tolower(choice);
		if (strchr("liq", choice) == NULL)
			puts("Введите букву l, i или q.");
		else
			break;
	}
	if (choice == EOF)
		choice = 'q';

	return choice;
}

static void eatline (void)
{
	while (getchar() != '\n')
		continue;
}
